"""
Конфигурация для продвинутого парсера описаний.

Этот модуль содержит все настройки для извлечения ДЛИННЫХ качественных описаний
из русской литературы для генерации изображений.

РЕВОЛЮЦИОННЫЕ ИЗМЕНЕНИЯ от классических подходов:
- Минимальная длина: 500 символов (было 50!)
- Оптимальная длина: 1000-2500 символов (было 150-500)
- Максимальная длина: 4000 символов (было 1000)
- Приоритет: ДЛИННЫЕ описания (2000-3500) получают наивысший приоритет
"""

from dataclasses import dataclass, field
from typing import Dict, List, Tuple
from enum import Enum


class ParagraphType(Enum):
    """Типы параграфов в тексте."""

    DESCRIPTION = "description"  # Описательный параграф (локация, персонаж, атмосфера)
    NARRATIVE = "narrative"  # Повествовательный параграф (действия, события)
    DIALOG = "dialog"  # Диалог между персонажами
    META = "meta"  # Служебный текст (заголовки, эпиграфы)
    MIXED = "mixed"  # Смешанный тип


class DescriptionType(Enum):
    """Типы описаний для генерации изображений."""

    LOCATION = "location"  # Описание места, локации
    CHARACTER = "character"  # Описание персонажа
    ATMOSPHERE = "atmosphere"  # Описание атмосферы, настроения
    OBJECT = "object"  # Описание объекта (обычно фильтруется)


@dataclass
class LengthPriorityZone:
    """Зона приоритета по длине описания."""

    min_chars: int
    max_chars: int
    priority_weight: float
    quality_threshold: float  # Минимальный порог качества для этой зоны


@dataclass
class AdvancedParserConfig:
    """
    Конфигурация продвинутого парсера описаний.

    Оптимизирована для извлечения ДЛИННЫХ качественных описаний (500-3500 символов)
    для генерации изображений в современных AI моделях:
    - Stable Diffusion 3: до 10,000 символов
    - DALL-E 3: до 4,000 символов с GPT-4 оптимизацией
    - Gemini Imagen 3: без ограничений, предпочитает детальные описания
    - Flux (pollinations.ai): 100-1000+ символов
    """

    # =========================================================================
    # Настройки длины описаний
    # =========================================================================

    # Минимальная длина для извлечения (было 50, стало 500!)
    min_char_length: int = 500

    # Максимальная длина (было 1000, стало 4000 для поддержки SD3 и DALL-E 3)
    max_char_length: int = 4000

    # Оптимальный диапазон длины (было 150-500, стало 1000-2500)
    optimal_char_range: Tuple[int, int] = (1000, 2500)

    # Зоны приоритета по длине
    length_priority_zones: Dict[str, LengthPriorityZone] = field(
        default_factory=lambda: {
            # КРИТИЧЕСКИ ВАЖНО: Очень длинные описания имеют НАИВЫСШИЙ приоритет!
            "very_long": LengthPriorityZone(
                min_chars=2000,
                max_chars=3500,
                priority_weight=2.5,  # Наивысший приоритет!
                quality_threshold=0.6,  # Можно снизить порог для длинных описаний
            ),
            "long": LengthPriorityZone(
                min_chars=1000,
                max_chars=2000,
                priority_weight=2.0,
                quality_threshold=0.65,
            ),
            "medium": LengthPriorityZone(
                min_chars=500,
                max_chars=1000,
                priority_weight=1.5,
                quality_threshold=0.7,
            ),
            # Короткие описания фильтруем агрессивно
            "short": LengthPriorityZone(
                min_chars=100,
                max_chars=500,
                priority_weight=0.5,  # Низкий приоритет
                quality_threshold=0.85,  # Очень высокий порог
            ),
        }
    )

    # =========================================================================
    # Настройки сегментации параграфов
    # =========================================================================

    # Минимальная длина параграфа для анализа
    min_paragraph_chars: int = 100

    # Максимальное количество параграфов в одном описании
    max_paragraphs_per_description: int = 20

    # Паттерны для определения типов параграфов
    dialog_markers: List[str] = field(
        default_factory=lambda: [
            "—",  # Русское тире
            "–",  # Короткое тире
            '"',  # Кавычки
            "«",  # Русские кавычки
            "»",
        ]
    )

    chapter_markers: List[str] = field(
        default_factory=lambda: [
            "ГЛАВА",
            "Глава",
            "ЧАСТЬ",
            "Часть",
            "РАЗДЕЛ",
            "Раздел",
            "ПРОЛОГ",
            "Пролог",
            "ЭПИЛОГ",
            "Эпилог",
        ]
    )

    meta_markers: List[str] = field(
        default_factory=lambda: [
            "***",
            "* * *",
            "---",
            "Эпиграф:",
            "От автора:",
        ]
    )

    # =========================================================================
    # Настройки детектирования границ описаний
    # =========================================================================

    # Размер окна lookahead для поиска продолжения описания
    lookahead_window_paragraphs: int = 20

    # Минимальная связность между параграфами для объединения (0.0-1.0)
    min_coherence_score: float = 0.5

    # Сигналы продолжения описания
    continuation_signals: List[str] = field(
        default_factory=lambda: [
            # Местоименные ссылки
            "Он",
            "Она",
            "Оно",
            "Они",
            "Его",
            "Её",
            "Их",
            "Этот",
            "Эта",
            "Это",
            "Эти",
            "Тот",
            "Та",
            "То",
            "Те",
            # Указательные
            "Здесь",
            "Там",
            "Тут",
            "Сюда",
            "Туда",
            # Союзы продолжения
            "И",
            "А",
            "Но",
            "Однако",
        ]
    )

    # Сигналы остановки (разрыва описания)
    stop_signals: List[str] = field(
        default_factory=lambda: [
            # Временные маркеры (начало нового действия)
            "Вдруг",
            "Внезапно",
            "Затем",
            "Потом",
            "После",
            "Через",
            "Спустя",
            # Действия персонажей
            "сказал",
            "сказала",
            "ответил",
            "ответила",
            "подумал",
            "подумала",
            "вспомнил",
            "вспомнила",
            # Начало диалога
            "—",
            "–",
        ]
    )

    # =========================================================================
    # Настройки многофакторной оценки качества
    # =========================================================================

    # Веса факторов (должны в сумме давать 1.0)
    confidence_weights: Dict[str, float] = field(
        default_factory=lambda: {
            "linguistic_quality": 0.30,  # Лингвистическое качество
            "visual_richness": 0.25,  # Визуальное богатство
            "structural_completeness": 0.20,  # Структурная полнота
            "type_specificity": 0.15,  # Специфичность типа
            "length_appropriateness": 0.10,  # Соответствие длины
        }
    )

    # Минимальные пороги для каждого фактора
    min_factor_scores: Dict[str, float] = field(
        default_factory=lambda: {
            "linguistic_quality": 0.4,
            "visual_richness": 0.3,
            "structural_completeness": 0.5,
            "type_specificity": 0.3,
            "length_appropriateness": 0.4,
        }
    )

    # Общий минимальный порог confidence для сохранения описания
    min_overall_confidence: float = 0.65  # Было 0.3, стало 0.65 (выше качество)

    # =========================================================================
    # Настройки визуального богатства (Visual Richness)
    # =========================================================================

    # Визуальные слова по категориям
    visual_keywords: Dict[str, List[str]] = field(
        default_factory=lambda: {
            "colors": [
                "белый",
                "черный",
                "красный",
                "синий",
                "зеленый",
                "желтый",
                "золотой",
                "серебряный",
                "багровый",
                "лазурный",
                "изумрудный",
                "алый",
                "пурпурный",
                "бирюзовый",
                "янтарный",
                "малиновый",
            ],
            "sizes": [
                "огромный",
                "большой",
                "маленький",
                "крошечный",
                "гигантский",
                "высокий",
                "низкий",
                "широкий",
                "узкий",
                "толстый",
                "тонкий",
            ],
            "textures": [
                "гладкий",
                "шершавый",
                "мягкий",
                "твердый",
                "пушистый",
                "бархатный",
                "шелковистый",
                "грубый",
                "скользкий",
                "липкий",
            ],
            "lighting": [
                "светлый",
                "темный",
                "яркий",
                "тусклый",
                "блестящий",
                "сияющий",
                "тенистый",
                "освещенный",
                "мерцающий",
                "сверкающий",
            ],
            "shapes": [
                "круглый",
                "квадратный",
                "треугольный",
                "овальный",
                "прямоугольный",
                "острый",
                "тупой",
                "изогнутый",
                "прямой",
                "волнистый",
            ],
            "materials": [
                "каменный",
                "деревянный",
                "металлический",
                "стеклянный",
                "кожаный",
                "тканевый",
                "мраморный",
                "бронзовый",
                "железный",
            ],
        }
    )

    # =========================================================================
    # Настройки типов описаний
    # =========================================================================

    # Индикаторы типов описаний
    type_indicators: Dict[str, List[str]] = field(
        default_factory=lambda: {
            "location": [
                # Места и пространства
                "место",
                "локация",
                "город",
                "деревня",
                "замок",
                "дом",
                "здание",
                "комната",
                "зал",
                "улица",
                "площадь",
                "парк",
                "лес",
                "гора",
                "река",
                "озеро",
                "море",
                "побережье",
                "остров",
                "долина",
                # Предлоги места
                "в",
                "на",
                "под",
                "над",
                "возле",
                "около",
                "рядом",
                "вокруг",
                # Пространственные характеристики
                "простирался",
                "возвышался",
                "находился",
                "располагался",
            ],
            "character": [
                # Внешность
                "лицо",
                "глаза",
                "волосы",
                "кожа",
                "нос",
                "губы",
                "руки",
                "фигура",
                "рост",
                "телосложение",
                "осанка",
                "походка",
                # Одежда
                "одежда",
                "платье",
                "костюм",
                "рубашка",
                "плащ",
                "мантия",
                "обувь",
                "украшения",
                "доспехи",
                "шляпа",
                "головной убор",
                # Внешний вид
                "выглядел",
                "выглядела",
                "казался",
                "казалась",
                "был одет",
                "была одета",
                "носил",
                "носила",
            ],
            "atmosphere": [
                # Настроение и чувства
                "атмосфера",
                "настроение",
                "ощущение",
                "чувство",
                "дух",
                "аура",
                "впечатление",
                "эмоция",
                # Описательные прилагательные
                "мрачный",
                "веселый",
                "тревожный",
                "спокойный",
                "напряженный",
                "торжественный",
                "таинственный",
                "зловещий",
                "радостный",
                # Сенсорные впечатления
                "пахло",
                "слышалось",
                "чувствовалось",
                "ощущалось",
            ],
        }
    )

    # =========================================================================
    # Настройки фильтрации антипаттернов
    # =========================================================================

    # Паттерны для фильтрации (не должны попадать в описания)
    antipatterns: Dict[str, List[str]] = field(
        default_factory=lambda: {
            "dialog_fragments": [
                r"—\s*[А-ЯЁ]",  # Начало реплики
                r"[.!?]\s*—",  # Конец реплики
                r"«[^»]+»",  # Прямая речь в кавычках
            ],
            "author_asides": [
                r"Автор[^.]+\.",
                r"От автора:",
                r"\([^)]{5,}\)",  # Длинные авторские комментарии в скобках
            ],
            "service_text": [
                r"^\s*\d+\s*$",  # Номера страниц
                r"^\s*Глава\s+\d+",  # Заголовки глав
                r"^\s*ГЛАВА\s+[IVXLCDM]+",  # Римские номера глав
                r"^\s*\*\s*\*\s*\*",  # Разделители
            ],
            "chapter_numbers": [
                r"^\s*\d+\s*$",
                r"^\s*[IVXLCDM]+\s*$",
            ],
            "epigraphs": [
                r"^\s*[—–]\s*[А-ЯЁ]",  # Цитаты с тире
                r"^\s*©",  # Copyright
            ],
        }
    )

    # =========================================================================
    # Настройки контекста и кореференции
    # =========================================================================

    # Максимальное расстояние между упоминаниями одной сущности (в параграфах)
    max_entity_distance: int = 50

    # Минимальная похожесть имен для определения кореференции (0.0-1.0)
    min_name_similarity: float = 0.8

    # Максимальный размер контекста для одной главы (в параграфах)
    max_chapter_context: int = 200

    # =========================================================================
    # Настройки производительности
    # =========================================================================

    # Максимальное время обработки одной главы (в секундах)
    max_chapter_processing_time: int = 300  # 5 минут

    # Максимальное время обработки всей книги (в секундах)
    max_book_processing_time: int = 1800  # 30 минут (по требованию пользователя)

    # Batch size для параллельной обработки параграфов
    paragraph_batch_size: int = 50

    # Использовать ли кэширование промежуточных результатов
    enable_caching: bool = True

    # =========================================================================
    # Настройки логирования и отладки
    # =========================================================================

    # Уровень детализации логов (debug, info, warning, error)
    log_level: str = "info"

    # Сохранять ли промежуточные результаты для отладки
    save_intermediate_results: bool = False

    # Путь для сохранения отладочной информации
    debug_output_path: str = "/tmp/advanced_parser_debug"

    def get_priority_weight(self, char_length: int) -> float:
        """
        Получить вес приоритета для описания заданной длины.

        Args:
            char_length: Длина описания в символах

        Returns:
            Вес приоритета (чем больше, тем выше приоритет)
        """
        for zone_name, zone in self.length_priority_zones.items():
            if zone.min_chars <= char_length <= zone.max_chars:
                return zone.priority_weight
        return 0.5  # Дефолтный низкий приоритет для нестандартных длин

    def get_quality_threshold(self, char_length: int) -> float:
        """
        Получить порог качества для описания заданной длины.

        Args:
            char_length: Длина описания в символах

        Returns:
            Минимальный порог confidence для сохранения
        """
        for zone_name, zone in self.length_priority_zones.items():
            if zone.min_chars <= char_length <= zone.max_chars:
                return zone.quality_threshold
        return 0.8  # Высокий порог для нестандартных длин

    def is_valid_length(self, char_length: int) -> bool:
        """
        Проверить, находится ли длина в допустимом диапазоне.

        Args:
            char_length: Длина описания в символах

        Returns:
            True если длина допустима
        """
        return self.min_char_length <= char_length <= self.max_char_length

    def is_optimal_length(self, char_length: int) -> bool:
        """
        Проверить, находится ли длина в оптимальном диапазоне.

        Args:
            char_length: Длина описания в символах

        Returns:
            True если длина оптимальна
        """
        return self.optimal_char_range[0] <= char_length <= self.optimal_char_range[1]


# Глобальная конфигурация по умолчанию
DEFAULT_CONFIG = AdvancedParserConfig()
