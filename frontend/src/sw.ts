// src/sw.ts - Custom Service Worker with Workbox (injectManifest)
// fancai PWA - Offline-first reading experience
//
// This file is compiled separately as a Service Worker.
// TypeScript types for Service Worker environment.

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching'
import { registerRoute, setDefaultHandler, setCatchHandler } from 'workbox-routing'
import { NetworkFirst, CacheFirst, StaleWhileRevalidate, NetworkOnly } from 'workbox-strategies'
import { ExpirationPlugin } from 'workbox-expiration'
import { CacheableResponsePlugin } from 'workbox-cacheable-response'
import { BackgroundSyncPlugin } from 'workbox-background-sync'

// Service Worker global scope
// Using globalThis cast to avoid TypeScript issues with webworker lib
const sw = globalThis as unknown as ServiceWorkerGlobalScope

// =============================================================================
// PRECACHING (Static Assets)
// =============================================================================

// Precache static resources (manifest generated by VitePWA at build time)
// @ts-expect-error - __WB_MANIFEST is injected by workbox at build time
precacheAndRoute(self.__WB_MANIFEST)

// Precache offline fallback page
precacheAndRoute([
  { url: '/offline.html', revision: '1' },
])

// Cleanup outdated caches from previous versions
cleanupOutdatedCaches()

// =============================================================================
// RUNTIME CACHING STRATEGIES
// =============================================================================

// --- Google Fonts Stylesheets ---
// CacheFirst: Fonts rarely change, cache for 1 year
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new CacheFirst({
    cacheName: 'google-fonts-stylesheets',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
)

// --- Google Fonts Webfonts ---
// CacheFirst: Font files are immutable (versioned URLs)
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
)

// --- API Requests ---
// NetworkFirst: Fresh data preferred, fallback to cache when offline
// SECURITY: Only cache GET requests, exclude auth endpoints
registerRoute(
  ({ url, request }) =>
    url.pathname.startsWith('/api/v1/') &&
    request.method === 'GET' &&
    // Exclude authentication endpoints (sensitive data)
    !url.pathname.startsWith('/api/v1/auth/') &&
    // Exclude admin endpoints (privileged access)
    !url.pathname.startsWith('/api/v1/admin/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 10,
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60, // 1 hour
      }),
    ],
  })
)

// --- Local Images (app assets) ---
// CacheFirst: Static assets rarely change
// Check for same-origin by comparing with registration scope
registerRoute(
  ({ request, url, sameOrigin }) =>
    request.destination === 'image' && sameOrigin,
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
)

// --- Pollinations.ai Generated Images ---
// CacheFirst: Generated images are immutable (content-addressed)
registerRoute(
  ({ url }) => url.hostname.includes('pollinations.ai'),
  new CacheFirst({
    cacheName: 'pollinations-images',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
)

// --- External Images (book covers, etc.) ---
// StaleWhileRevalidate: Show cached, update in background
registerRoute(
  ({ request, url, sameOrigin }) =>
    request.destination === 'image' &&
    !sameOrigin &&
    !url.hostname.includes('pollinations.ai'),
  new StaleWhileRevalidate({
    cacheName: 'external-images',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
  })
)

// --- Static Assets (JS, CSS, WOFF2) ---
// StaleWhileRevalidate: Fast load, update in background
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style' ||
    request.destination === 'font',
  new StaleWhileRevalidate({
    cacheName: 'static-assets',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
)

// =============================================================================
// BACKGROUND SYNC (Critical Operations)
// =============================================================================

// --- Critical Sync Queue (reading progress, sessions) ---
// NetworkOnly + BackgroundSync: Queue when offline, replay when online
const criticalSyncPlugin = new BackgroundSyncPlugin('fancai-critical-sync', {
  maxRetentionTime: 24 * 60, // 24 hours in minutes
  onSync: async ({ queue }) => {
    let entry: Awaited<ReturnType<typeof queue.shiftRequest>>
    while ((entry = await queue.shiftRequest())) {
      try {
        const response = await fetch(entry.request.clone())
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`)
        }
        // Notify clients about successful sync
        const clients = await sw.clients.matchAll()
        const requestUrl = entry.request.url
        const requestMethod = entry.request.method
        clients.forEach(client => {
          client.postMessage({
            type: 'SYNC_SUCCESS',
            url: requestUrl,
            method: requestMethod,
          })
        })
      } catch (error) {
        // Return to queue for retry
        await queue.unshiftRequest(entry)
        throw error
      }
    }
  },
})

// Reading progress - POST
registerRoute(
  ({ url }) => url.pathname.match(/\/api\/v1\/books\/[^/]+\/progress$/) !== null,
  new NetworkOnly({
    plugins: [criticalSyncPlugin],
  }),
  'POST'
)

// Reading progress - PUT
registerRoute(
  ({ url }) => url.pathname.match(/\/api\/v1\/books\/[^/]+\/progress$/) !== null,
  new NetworkOnly({
    plugins: [criticalSyncPlugin],
  }),
  'PUT'
)

// Reading sessions - POST
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/v1/reading-sessions'),
  new NetworkOnly({
    plugins: [criticalSyncPlugin],
  }),
  'POST'
)

// Reading sessions - PUT
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/v1/reading-sessions'),
  new NetworkOnly({
    plugins: [criticalSyncPlugin],
  }),
  'PUT'
)

// --- Image Sync Queue (less critical, longer retention) ---
const imageSyncPlugin = new BackgroundSyncPlugin('fancai-image-sync', {
  maxRetentionTime: 7 * 24 * 60, // 7 days in minutes
})

// Image generation requests
registerRoute(
  ({ url }) => url.pathname.match(/\/api\/v1\/images\/generate/) !== null,
  new NetworkOnly({
    plugins: [imageSyncPlugin],
  }),
  'POST'
)

// =============================================================================
// NAVIGATION HANDLING (with Navigation Preload)
// =============================================================================

// SPA Navigation: Serve index.html for all navigation requests
// This enables client-side routing to work offline
//
// Navigation Preload optimization:
// When enabled, the browser starts fetching the navigation request in parallel
// with service worker startup. We check for preloadResponse first, which can
// save ~50-100ms on navigation requests.

const navigationHandler = new NetworkFirst({
  cacheName: 'navigation-cache',
  networkTimeoutSeconds: 5,
  plugins: [
    new CacheableResponsePlugin({ statuses: [0, 200] }),
  ],
})

// Custom navigation route that uses Navigation Preload when available
registerRoute(
  ({ request }) => request.mode === 'navigate' && !request.url.includes('/api/'),
  async ({ event, request }) => {
    try {
      // Try to use the preloaded response first (Navigation Preload)
      // This is the key optimization - the preload request runs in parallel
      // with service worker startup, potentially saving ~50-100ms
      const preloadResponse = await (event as FetchEvent).preloadResponse
      if (preloadResponse) {
        console.log('[SW] Using preloaded navigation response')
        // Cache the preloaded response for offline use
        const cache = await caches.open('navigation-cache')
        cache.put(request, preloadResponse.clone())
        return preloadResponse
      }
    } catch (error) {
      console.log('[SW] Navigation preload failed, falling back to NetworkFirst:', error)
    }

    // Fall back to standard NetworkFirst strategy
    // This handles cases where:
    // - Navigation Preload is not supported
    // - Preload failed
    // - We're offline (will serve from cache)
    return navigationHandler.handle({ event, request })
  }
)

// =============================================================================
// DEFAULT HANDLER
// =============================================================================

// Fallback strategy for any unmatched requests
setDefaultHandler(
  new NetworkFirst({
    cacheName: 'default-cache',
    networkTimeoutSeconds: 10,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 1 day
      }),
    ],
  })
)

// =============================================================================
// OFFLINE FALLBACK HANDLER
// =============================================================================

// Catch handler for failed requests - serve offline page for navigation
setCatchHandler(async ({ request }) => {
  // Only serve offline fallback for navigation requests (HTML pages)
  if (request.destination === 'document') {
    // Try to get the offline page from precache
    const cache = await caches.open('workbox-precache-v2-' + self.location.origin + '/')
    const cachedResponse = await cache.match('/offline.html')
    if (cachedResponse) {
      return cachedResponse
    }

    // Fallback: try to find offline.html in any cache
    const cacheNames = await caches.keys()
    for (const cacheName of cacheNames) {
      const c = await caches.open(cacheName)
      const response = await c.match('/offline.html')
      if (response) {
        return response
      }
    }
  }

  // For non-navigation requests, return error response
  return Response.error()
})

// =============================================================================
// MESSAGE HANDLING
// =============================================================================

// Handle messages from the client
sw.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    console.log('[SW] Skip waiting requested')
    sw.skipWaiting()
  }
})

// =============================================================================
// BACKGROUND SYNC EVENT HANDLERS
// =============================================================================

// Handle manual sync registration from the app (for custom Dexie-based queue)
sw.addEventListener('sync', ((event: SyncEvent) => {
  console.log('[SW] Background sync triggered:', event.tag)

  // Handle custom app-level sync (for iOS fallback and custom queue)
  if (event.tag === 'fancai-sync') {
    event.waitUntil(handleFancaiSync())
  } else if (event.tag === 'reading-progress-sync') {
    event.waitUntil(handleReadingProgressSync())
  } else if (event.tag === 'offline-queue-sync') {
    event.waitUntil(handleOfflineQueueSync())
  }
  // Note: 'fancai-critical-sync' and 'fancai-image-sync' are handled by BackgroundSyncPlugin
}) as EventListener)

async function handleFancaiSync(): Promise<void> {
  console.log('[SW] Fancai sync - notifying clients to process Dexie queue')
  const clients = await sw.clients.matchAll()
  clients.forEach((client) => {
    client.postMessage({ type: 'SYNC_REQUESTED', tag: 'fancai-sync' })
  })
}

async function handleReadingProgressSync(): Promise<void> {
  console.log('[SW] Reading progress sync - handled by syncQueue service')
  const clients = await sw.clients.matchAll()
  clients.forEach((client) => {
    client.postMessage({ type: 'SYNC_REQUESTED', tag: 'reading-progress-sync' })
  })
}

async function handleOfflineQueueSync(): Promise<void> {
  console.log('[SW] Offline queue sync - handled by syncQueue service')
  const clients = await sw.clients.matchAll()
  clients.forEach((client) => {
    client.postMessage({ type: 'SYNC_REQUESTED', tag: 'offline-queue-sync' })
  })
}

// =============================================================================
// PUSH NOTIFICATIONS
// =============================================================================

/**
 * Push notification payload type
 */
interface PushPayload {
  title?: string
  body?: string
  icon?: string
  badge?: string
  tag?: string
  data?: {
    type?: 'book_ready' | 'image_ready' | 'sync_complete' | 'general'
    url?: string
    bookId?: string
    bookTitle?: string
    chapterNumber?: number
    imageId?: string
    descriptionId?: string
    timestamp?: number
  }
  actions?: Array<{ action: string; title: string; icon?: string }>
  requireInteraction?: boolean
  vibrate?: number[]
}

/**
 * Default notification options by type
 */
function getNotificationOptions(type: string, payload: PushPayload): NotificationOptions {
  const baseOptions: NotificationOptions = {
    icon: payload.icon || '/favicon-192.png',
    badge: payload.badge || '/favicon-72.png',
    data: payload.data || { type: 'general', url: '/' },
    vibrate: payload.vibrate || [100, 50, 100],
  }

  switch (type) {
    case 'book_ready':
      return {
        ...baseOptions,
        tag: payload.tag || `book-ready-${payload.data?.bookId || Date.now()}`,
        requireInteraction: payload.requireInteraction ?? true,
        actions: payload.actions || [
          { action: 'read', title: 'Start Reading' },
          { action: 'later', title: 'Read Later' },
        ],
      }

    case 'image_ready':
      return {
        ...baseOptions,
        tag: payload.tag || `image-ready-${payload.data?.imageId || Date.now()}`,
        requireInteraction: false,
        actions: payload.actions || [
          { action: 'view', title: 'View Image' },
          { action: 'dismiss', title: 'Dismiss' },
        ],
      }

    case 'sync_complete':
      return {
        ...baseOptions,
        tag: payload.tag || 'sync-complete',
        requireInteraction: false,
        actions: payload.actions || [
          { action: 'view', title: 'View' },
        ],
      }

    default:
      return {
        ...baseOptions,
        tag: payload.tag || `notification-${Date.now()}`,
        actions: payload.actions || [
          { action: 'view', title: 'View' },
          { action: 'dismiss', title: 'Dismiss' },
        ],
      }
  }
}

/**
 * Get default title and body for notification type
 */
function getDefaultContent(type: string, data?: PushPayload['data']): { title: string; body: string } {
  switch (type) {
    case 'book_ready':
      return {
        title: 'Book Ready',
        body: data?.bookTitle
          ? `"${data.bookTitle}" is ready for reading`
          : 'Your book has been processed and is ready for reading',
      }

    case 'image_ready':
      return {
        title: 'Image Generated',
        body: data?.bookTitle
          ? `New image for "${data.bookTitle}" is ready`
          : 'Your AI-generated image is ready',
      }

    case 'sync_complete':
      return {
        title: 'Sync Complete',
        body: 'Your reading progress has been synchronized',
      }

    default:
      return {
        title: 'fancai',
        body: 'You have a new notification',
      }
  }
}

/**
 * Push event handler
 *
 * Receives push messages from the server and displays notifications.
 * Supports different notification types: book_ready, image_ready, sync_complete
 */
sw.addEventListener('push', ((event: PushEvent) => {
  console.log('[SW] Push received:', event)

  let payload: PushPayload = {}

  // Parse push data
  if (event.data) {
    try {
      payload = event.data.json() as PushPayload
      console.log('[SW] Push payload:', payload)
    } catch {
      // If not JSON, use text as body
      payload = {
        body: event.data.text(),
        data: { type: 'general', url: '/' },
      }
    }
  }

  // Determine notification type
  const notificationType = payload.data?.type || 'general'

  // Get default content if not provided
  const defaultContent = getDefaultContent(notificationType, payload.data)

  // Build notification options
  const options = getNotificationOptions(notificationType, payload)

  // Set body from payload or default
  options.body = payload.body || defaultContent.body

  // Determine title
  const title = payload.title || defaultContent.title

  // Show notification
  event.waitUntil(
    sw.registration.showNotification(title, options).then(() => {
      // Notify all clients about the push (for in-app handling)
      return sw.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clients) => {
        clients.forEach((client) => {
          client.postMessage({
            type: 'PUSH_RECEIVED',
            payload,
            timestamp: Date.now(),
          })
        })
      })
    })
  )
}) as EventListener)

/**
 * Notification click handler
 *
 * Handles user clicking on notification or action buttons.
 * Routes to appropriate URL based on notification type and action.
 */
sw.addEventListener('notificationclick', ((event: NotificationClickEvent) => {
  console.log('[SW] Notification clicked:', event.action, event.notification.data)

  // Close the notification
  event.notification.close()

  const data = event.notification.data || {}
  const action = event.action
  const type = data.type || 'general'

  // Handle dismiss action - just close, don't navigate
  if (action === 'dismiss' || action === 'later') {
    console.log('[SW] Notification dismissed')
    return
  }

  // Determine URL based on notification type and action
  let url = data.url || '/'

  if (!data.url) {
    switch (type) {
      case 'book_ready':
        if (data.bookId) {
          url = action === 'read' ? `/reader/${data.bookId}` : `/library`
        } else {
          url = '/library'
        }
        break

      case 'image_ready':
        if (data.bookId && data.chapterNumber) {
          url = `/reader/${data.bookId}?chapter=${data.chapterNumber}`
        } else if (data.bookId) {
          url = `/reader/${data.bookId}`
        } else {
          url = '/library'
        }
        break

      case 'sync_complete':
        url = '/library'
        break

      default:
        url = '/'
    }
  }

  // Handle navigation
  event.waitUntil(
    sw.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      // Check if a window with the URL is already open
      for (const client of clientList) {
        if (client.url.includes(url) && 'focus' in client) {
          // Focus existing window
          return (client as WindowClient).focus().then((focusedClient) => {
            // Notify client about the click
            focusedClient?.postMessage({
              type: 'NOTIFICATION_CLICKED',
              action,
              data,
              timestamp: Date.now(),
            })
            return focusedClient
          })
        }
      }

      // Check if any window is open (to navigate instead of open new)
      for (const client of clientList) {
        if ('focus' in client && 'navigate' in client) {
          return (client as WindowClient).focus().then((focusedClient) => {
            if (focusedClient && 'navigate' in focusedClient) {
              return (focusedClient as WindowClient & { navigate: (url: string) => Promise<WindowClient> }).navigate(url).then((navigatedClient) => {
                navigatedClient?.postMessage({
                  type: 'NOTIFICATION_CLICKED',
                  action,
                  data,
                  timestamp: Date.now(),
                })
                return navigatedClient
              })
            }
            return focusedClient
          })
        }
      }

      // No windows open, open a new one
      return sw.clients.openWindow(url).then((newClient) => {
        newClient?.postMessage({
          type: 'NOTIFICATION_CLICKED',
          action,
          data,
          timestamp: Date.now(),
        })
        return newClient
      })
    })
  )
}) as EventListener)

/**
 * Notification close handler (optional)
 *
 * Tracks when notifications are closed without interaction.
 * Can be used for analytics.
 */
sw.addEventListener('notificationclose', ((event: NotificationEvent) => {
  console.log('[SW] Notification closed:', event.notification.data)

  // Could send analytics here if needed
  // For now, just log
}) as EventListener)

// =============================================================================
// LIFECYCLE EVENTS
// =============================================================================

sw.addEventListener('install', () => {
  console.log('[SW] Service Worker installing (Workbox injectManifest)')
})

sw.addEventListener('activate', (event) => {
  console.log('[SW] Service Worker activated (Workbox injectManifest)')

  // Enable Navigation Preload for faster navigation (~50-100ms improvement)
  // Navigation Preload allows the browser to start fetching the navigation request
  // in parallel with service worker startup, instead of waiting for SW to boot.
  event.waitUntil(
    (async () => {
      if ('navigationPreload' in sw.registration) {
        try {
          await sw.registration.navigationPreload.enable()
          console.log('[SW] Navigation Preload enabled')
        } catch (error) {
          console.warn('[SW] Failed to enable Navigation Preload:', error)
        }
      } else {
        console.log('[SW] Navigation Preload not supported')
      }
    })()
  )
})

console.log('[SW] Custom Service Worker loaded with Workbox')
